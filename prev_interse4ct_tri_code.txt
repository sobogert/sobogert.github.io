/*
  for (int k = 0; k < num_triangles; k++)
  {
		Triangle triangle = triangles[k];
    
    // Make sure ray is not parallel to plane of triangle

    // Calculate plane of triangle
    glm::vec3 v0 = glm::vec3(triangle.v[0].position[0], triangle.v[0].position[1], triangle.v[0].position[2]);
    glm::vec3 v1 = glm::vec3(triangle.v[1].position[0], triangle.v[1].position[1], triangle.v[1].position[2]);
    glm::vec3 v2 = glm::vec3(triangle.v[2].position[0], triangle.v[2].position[1], triangle.v[2].position[2]);

    glm::vec3 edge01 = v1 - v0;
    glm::vec3 edge02 = v2 - v0;

    glm::vec3 normal = glm::cross(edge01, edge02);
    normal = glm::normalize(normal);

    // Make sure ray is not parallel to plane
    float dot = glm::dot(normal, ray.direction);
    if (dot == 0.0f)
    {
      return;
    }  

		// Calculate intersection point
    float d = -1.0f * glm::dot(normal, v0);
		float t = -1.0f * (glm::dot(origin, normal) + d) / dot;
		if (t <= 0.0f)
		{
			return;
		}
    
    glm::vec3 point = ray.direction * t;
    point += origin;

    glm::vec3 vec_point = point - v0;

    float a = 0.0f;
    float b = 0.0f;

    float leftMult = edge01.x * edge02.y;
    float rightMult = edge02.x * edge01.y;
    float denom = leftMult - rightMult;
    if (leftMult == rightMult)
    {
      a = -1.0f;
      b = -1.0f;
    }
    else
    {
      a = (edge02.x * (vec_point.y * -1.0f) + vec_point.x * edge02.y) / denom;
      b = (edge01.y * (vec_point.x * -1.0f) + vec_point.y * edge01.x) / denom;
    }

    if ((a <= 0.0f) || (b <= 0.0f) || ((a + b) >= 1))
    {
      return;
    }
    ray.color.x = 255;
    ray.color.y = 0;
    ray.color.z = 130;
		// Calculate position of intersection
		glm::vec3 intersection = origin + (t * ray.direction);


		// Make sure it is not behind any spheres
		if (intersection.z < sphere_intersections[(int)ray.image_pos.x][(int)ray.image_pos.y])
		{
			return;
		}
		// Make sure it is not behind any triangles
		else if (intersection.z < triangle_intersections[(int)ray.image_pos.x][(int)ray.image_pos.y])
		{
			return;
		}
		// If there is no sphere in front of it, color it
		else
		{
			// Store intersection point
			triangle_intersections[(int)ray.image_pos.x][(int)ray.image_pos.y] = intersection.z;

			phong_triangle(intersection, ray, k, hit);
		}
    
  }
  */